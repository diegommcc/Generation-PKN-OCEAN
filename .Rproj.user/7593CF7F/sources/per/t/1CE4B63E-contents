---
title: "01 - Exploration of mouse genome-scale metabolic models"
output: html_document
date: '2023-09-22'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
## paths
projectPath <- here::here()
dataPath <- here::here("data")
metadataPath <- here::here("metadata")
sourceCode <- here::here("src")
objectsPath <- here::here("objects", "01.Exploring.Models")
reportsPath <- here::here("reports", "01.Exploring.Models")
plotsPath <- here::here(reportsPath, "plots")
prefix <- "01.Exploring.Models"

## scr code
# source(file.path(sourceCode, "helperFunctions.R"))

## R packages
library("XML")
library("dplyr")

## rmarkdown settings
knitr::opts_chunk$set(
  echo = FALSE,
  fig.align = "center",
  fig.path = file.path(reportsPath, "plots/"),
  fig.pos = "H",
  message = FALSE,
  warning = FALSE,
  comment = NA,
  dev = c("png"),
  dpi = 300
)

## global options
options(encoding = 'UTF-8')
```

# Exploring genome scale metabolic models

The very firt step consists of the creation of a genome scale metabolic model for mouse + adapt the network to the specific format that COSMOS needs.There are some preexisting GSMMs for mouse, so I think I am going to use one of them and adapt it to using it by COSMOS. 

The options are: 

1. iMM1865: it comes from a Scientific Reports (<https://www.nature.com/articles/s41598-020-63235-w>) and is available at here: <https://www.ebi.ac.uk/biomodels/MODEL2110030001>. 
2. This model comes from the following paper (<https://www.pnas.org/doi/10.1073/pnas.2102344118>) and is available at <https://github.com/SysBioChalmers/Mouse-GEM>. 

In general, in this web page there are different models that eventually could be interesting for us: <https://www.ebi.ac.uk/biomodels/search?query=*%3A*>. I've tried to filter by organism and seems to be impossible. There are more models than just metabolic models, so Idk... 

# Models

## iMM1865

It is in the L3V1 format. It is an XMLs. 

```{r}
data <- xmlParse(file.path(dataPath, "iMM1865", "iMM1865.xml"))
```

```{r}
list.data <- xmlToList(data)
```

### Gene products

```{r}
length(list.data$model$listOfGeneProducts)
list.data$model$listOfGeneProducts[[5]]$.attrs
```

Ok, once I have built the list, I can access to it like that- I think the best way is going to do a lapply and extract all the attr elements: 

```{r}
geneProducts.DF <- lapply(
  seq_along(list.data$model$listOfGeneProducts), 
  \(x) {
    as.data.frame(t(as.data.frame(list.data$model$listOfGeneProducts[[x]]$.attrs)))
  }
) %>% do.call(rbind, .)
```


### List of groups

```{r}
groups.list <- lapply(
  seq_along(list.data$model$listOfGroups), 
  \(x) {
    members.vec <- sapply(
      seq_along(list.data$model$listOfGroups[[x]]$listOfMembers), \(y) {
        list.data$model$listOfGroups[[x]]$listOfMembers[[y]] %>% as.vector()
      }
    )
    df <- as.data.frame(t(as.data.frame(list.data$model$listOfGroups[[x]]$.attrs)))
    return(list(df, members.vec))
  }
) 
```


### List of species

```{r}
names(list.data$model)
```


```{r}
species.list <- lapply(
  seq_along(list.data$model$listOfSpecies), 
  \(x) {
    df <- list.data$model$listOfSpecies[[x]]$.attrs %>% as.data.frame() %>% t() %>%
      as.data.frame()
    if (dim(df)[2] != 9) {
      df <- df %>% mutate(chemicalFormula = NA, .after = 4)
    }
    return(df)
  }
) 
```

There is one entry with a different number of columns. 

```{r}
which(sapply(species.list, \(x) dim(x)[2]) != 9)
```

```{r}
species.list[2]
species.list[5834]
```


```{r}
species.df <- lapply(
  seq_along(list.data$model$listOfSpecies), 
  \(x) {
    df <- list.data$model$listOfSpecies[[x]]$.attrs %>% as.data.frame() %>% t() %>%
      as.data.frame()
    if (dim(df)[2] != 9) {
      df <- df %>% mutate(chemicalFormula = NA, .after = 4)
    }
    return(df)
  }
) %>% do.call(rbind, .)
species.df
```

### List of reactions

```{r}
list.data$model$listOfReactions[[10]]$.attrs
```

```{r}
reactions.df <- lapply(
  seq_along(list.data$model$listOfReactions), 
  \(x) {
    df <- list.data$model$listOfReactions[[x]]$.attrs %>% as.data.frame() %>% t() %>%
      as.data.frame()
    return(df)
  }
) %>% do.call(rbind, .)
# reactions.df
```



```{r}
list.data$model$listOfReactions[[10]]$listOfReactants
list.data$model$listOfReactions[[10]]$listOfProducts
```


```{r}
reactions.df <- lapply(
  seq_along(list.data$model$listOfReactions), 
  \(x) {
    df <- list.data$model$listOfReactions[[x]]$.attrs %>% as.data.frame() %>% t() %>%
      as.data.frame()
    return(df)
  }
) %>% do.call(rbind, .)
```


## Conclusions

I think this contains all the information that the other format has, but it is not trivial to extract it. Indeed, the stroichiometric matrix (which in principle is encoded in one of the entries) is not built in the same way, and I would needed it to 

## Checking Aurelien's example

It is not complete and I should check the output of some of the parts, I am not sure if the Wang et al., 2021 is correctly done. 

```{r}
library("R.matlab")
library("dplyr")
library("stringr")
library(readr)
# library(ocean)
```

```{r}
#from BIGG db (http://bigg.ucsd.edu/models/Recon3D)
recon3D_BIGG <- readMat(file.path(dataPath, "Recon3D.BIGG", "Recon3D.mat"))

#From VHM (https://www.vmh.life/files/reconstructions/Recon/3D.01/)
# recon3D_paper <- readMat("Recon3DModel_301.mat")

recon3D_BIGG <- recon3D_BIGG$Recon3D
# recon3D_paper <- recon3D_paper$Recon3DModel
recon3D_BIGG
```

Ok, now I can see what he is taking in every step:

```{r}
rownames(recon3D_BIGG)[11] ## stochoimetric matrix
rownames(recon3D_BIGG)[7] ## reaction list
rownames(recon3D_BIGG)[c(12, 13, 16)] ## direction reactions
rownames(recon3D_BIGG)[8] ## reaction ids
rownames(recon3D_BIGG)[1] ## metabolites
rownames(recon3D_BIGG)[2] ## metabolites names
rownames(recon3D_BIGG)[15] ## metabolites names
```

This is from the BIGG ddbb. In the case of the ddbb from the paper, he takes some annotations for HMDB format. 

```{r}
#get the stochio matrix
S <- as.matrix(recon3D_BIGG[[11]])

#get the list of gene rules for reactions
reaction_list <- recon3D_BIGG[[7]]
```

```{r}
#get reversible reactions
lbs <- as.data.frame(cbind(recon3D_BIGG[[12]],recon3D_BIGG[[13]],recon3D_BIGG[[16]]))
lbs$direction <- ifelse((recon3D_BIGG[[13]] + recon3D_BIGG[[12]]) >= 0,"forward","backward")
reversible <- ifelse(recon3D_BIGG[[16]] == 1, TRUE, FALSE)

#get the reaction ids
reaction_ids <- unlist(recon3D_BIGG[[8]])
```


```{r, eval = FALSE}
gene_mapping <- recon2_redhuman$gene_mapping
gene_mapping_vec <- gene_mapping$name
names(gene_mapping_vec) <- as.character(gene_mapping$X1)
```

Checking manually first iteration

```{r}
i <- 1
#create a dataframe to map reaction indexes with genes
reaction_to_genes <- list()
for(i in 1:length(reaction_list))
{
  if(length(reaction_list[[i]][[1]] > 0))
  {
    lol <- F
    genes <- unique(gsub(" and ","_",gsub("[()]","",gsub("_AT[0-9]+","",strsplit(reaction_list[[i]][[1]], split = " or ")[[1]]))))
    df <- as.data.frame(matrix(NA,length(genes), 2))
    df[,1] <- i
    if(sum(as.character(genes) %in% names(gene_mapping_vec)) > 0)
    {
      for(k in 1:length(as.character(genes)))
      {
        if(as.character(genes[k]) %in% names(gene_mapping_vec))
        {
          genes[k] <- gene_mapping_vec[as.character(genes[k])]
        }
      }
      
    } else
    {
      for(k in 1:length(genes))
      {
        if(grepl("_",genes[k]))
        {
          if(grepl("4967",genes[k]))
          {
            print(genes[k])
            lol <- T
          }
          genes_splitted <- strsplit(genes[k], split = "_")[[1]]
          for(j in 1:length(genes_splitted))
          {
            if(lol) print(genes_splitted[j])
            if(as.character(genes_splitted[j]) %in% names(gene_mapping_vec))
            {
              genes_splitted[j] <- gene_mapping_vec[as.character(genes_splitted[j])]
            }
            if(lol) print(genes_splitted[j])
          }
          genes[k] <- paste0(genes_splitted, collapse = "_")
          if(lol) print(genes)
          if(lol) print(i)
        }
      }
      
    }
    df[,2] <- genes
    reaction_to_genes[[i]] <- df
  } else
  {
    df <- as.data.frame(matrix(NA,1, 2))
    df[,1] <- i
    df[,2] <- reaction_ids[i]
    reaction_to_genes[[i]] <- df
  }
}
```



## Wang et al., 2021

The data comes from this Github repo: <https://github.com/SysBioChalmers/Mouse-GEM>. They provide not only the model, but also a set of scripts that eventually could be used to create a new one. They provide the model in several formatsS: mat format, xml format (I guess it's the same format as the previous one) and yml format. They also provide two tsv with metabolites and reactions. I am going to follow the recommendations and load the matlab format using the code of Aurelien. As I need to know what is every part in his code, i am going to follow his tutorial and then apply the same steps to my model.  

**Note** the following code comes from this github: <https://github.com/saezlab/recon3D_BIGG/blob/main/script/recon3DBIGG_to_df.R>

```{r}
#from BIGG db (http://bigg.ucsd.edu/models/Recon3D)
mouseGEM.mat <- readMat(file.path(dataPath, "Mouse-GEM/model", "Mouse-GEM.mat"))[[1]]
```

```{r}
S.mouseGEM <- mouseGEM.mat[[5]]
reaction_list.mouseGEM <- mouseGEM.mat[[which(rownames(mouseGEM.mat) == "grRules")]]
```

```{r}
which(rownames(mouseGEM.mat) == "lb")
which(rownames(mouseGEM.mat) == "ub")
which(rownames(mouseGEM.mat) == "rev")
# get reversible reactions
lbs <- as.data.frame(
  cbind(
    mouseGEM.mat[[which(rownames(mouseGEM.mat) == "lb")]],
    mouseGEM.mat[[which(rownames(mouseGEM.mat) == "ub")]],
    mouseGEM.mat[[which(rownames(mouseGEM.mat) == "rev")]]
  )
)
lbs$direction <- ifelse(
  (mouseGEM.mat[[which(rownames(mouseGEM.mat) == "ub")]] + 
     mouseGEM.mat[[which(rownames(mouseGEM.mat) == "lb")]]) >= 0,
  "forward", "backward"
)
reversible <- ifelse(mouseGEM.mat[[which(rownames(mouseGEM.mat) == "rev")]] == 1, TRUE, FALSE)
```

```{r}
nrow(lbs) == dim(S.mouseGEM)[2]
```



```{r}
#get the reaction ids
reaction_ids.mouseGEM <- unlist(mouseGEM.mat[[which(rownames(mouseGEM.mat) == "rxns")]])
reaction_ids.mouseGEM %>% head()
```

I guess this is just a vector to match different ways to annotate genes. I haven't found that function, so Idk from what to what annotation is done. Anyway, let's continue and see if I can do anything like that using BioMart or whatever. 

```{r, eval = FALSE}
gene_mapping <- recon2_redhuman$gene_mapping
gene_mapping_vec <- gene_mapping$name
names(gene_mapping_vec) <- as.character(gene_mapping$X1)
```

In this part, he creates a dataframe to map reaction indexes with genes. Rather than just running the for loop, let's take a look at the first iteration: 

```{r}
# reaction_list.mouseGEM
# reaction_list.mouseGEM[[i]][[1]]
reaction_list.mouseGEM[[30]][[1]]
```


```{r}
# reaction_list.mouseGEM[[1]][[1]]
# which(sapply(reaction_list.mouseGEM, \(x) length(x[[1]])) == 0)
```

Testing how it works: 

```{r, eval = FALSE}
i <- 79
genes <- unique(
  gsub(" and ","_",gsub("[()]","",gsub("_AT[0-9]+","", strsplit(reaction_list.mouseGEM[[i]][[1]], split = " or ")[[1]])))
)
df <- as.data.frame(matrix(NA,length(genes), 2))
df[,1] <- i
df[,2] <- genes
reaction_to_genes[[i]] <- df
```

Ok, now I understand. The code is wrong in some parts, but still can be used as follows: 

```{r}
reaction_to_genes.mouseGEM <- list()
for (i in 1:length(reaction_list.mouseGEM)) {
  if (dim(reaction_list.mouseGEM[[i]][[1]])[1] != 0) {
    genes <- unique(
      gsub(" and ", "_", gsub("[()]","", gsub("_AT[0-9]+","", strsplit(reaction_list.mouseGEM[[i]][[1]], split = " or ")[[1]])))
    )
    df <- as.data.frame(matrix(NA,length(genes), 2))
    df[,1] <- i
    df[,2] <- genes
    reaction_to_genes.mouseGEM[[i]] <- df
  } else {
    df <- as.data.frame(matrix(NA,length(genes), 2))
    df[,1] <- i
    df[,2] <- reaction_ids.mouseGEM[i]
    reaction_to_genes.mouseGEM[[i]] <- df
  }
}
```

```{r}
reaction_to_genes.mouseGEM <- as.data.frame(do.call(rbind, reaction_to_genes.mouseGEM))
reaction_to_genes.mouseGEM[grepl("MAR\\d?",reaction_to_genes.mouseGEM$V2),"V2"] <- paste(
  "orphanReac", reaction_to_genes.mouseGEM[grepl("MAR\\d?", reaction_to_genes.mouseGEM$V2),"V2"], 
  sep = ""
)
dim(reaction_to_genes.mouseGEM)
reaction_to_genes.mouseGEM <- unique(reaction_to_genes.mouseGEM)
dim(reaction_to_genes.mouseGEM)
reaction_to_genes.mouseGEM.original <- reaction_to_genes.mouseGEM
```

Now, we have a dataframe where every reaction is linked to a gene. We have to do the same thing for metabolites. Here the problem is that he uses info from the Recond3 from the paper, which contains metabolites annotated using the HMDB ddbb, which is better. In addition, he uses the BIGG annotation when the other one is not available.

In my case, the only annotation that i have is from Metabolic Atlas, which I don't think is really established. Checking the we page, there is info about each metabolite and cross-references from different databases, so may be I could try to download that infor and transform my metabolites to any other notation: <https://ftp.metabolicatlas.org/api/v2/#/Reactions/reactionInfo>.

In their API, you can retrieve information about metabolites and reactions annotated with their IDs. I am going to download that info and make the translations. 

```{r}
mouseGEM.mat[[which(rownames(mouseGEM.mat) == "rxnNames")]] %>% unlist()
mouseGEM.mat[[which(rownames(mouseGEM.mat) == "rxnNames")]] %>% unlist()
mouseGEM.mat[[which(rownames(mouseGEM.mat) == "inchis")]] %>% unlist()
mouseGEM.mat[[which(rownames(mouseGEM.mat) == "metFormulas")]] %>% unlist()
mouseGEM.mat[[which(rownames(mouseGEM.mat) == "metComps")]] %>% unlist()
```



```{r}
#get metabolites
metabolites.mouseGEM <- mouseGEM.mat[[which(rownames(mouseGEM.mat) == "mets")]] %>% unlist()
metabolites_names.mouseGEM <- unlist(mouseGEM.mat[[which(rownames(mouseGEM.mat) == "metNames")]])
metabolites_formulas.mouseGEM <- unlist(mouseGEM.mat[[which(rownames(mouseGEM.mat) == "metFormulas")]])
```

i have the ID from the metabolic atlas, but it's likely I will need the ID from other databases. This info can be extracted from the Metabolic Atlas web page, which have an API access. Here s is the URL I have to use: <https://ftp.metabolicatlas.org/api/v2/#/Metabolites/metaboliteInfo>. It returns a JSON file which I should be able to parse in R. 

The API is not working, so I guess i cannot do anything with this... From the MACOS is does not work either.

```{r, eval = FALSE}
library(httr)
library(jsonlite)

res <- GET("https://ftp.metabolicatlas.org/api/v2/metabolites/MAM00001c?model=MouseGem", add_headers(Accept = 'application/json'))
```
**Solution** 

The error is in the URL I sed as query. It seems that the version in the web page is not correct. The proper URL should be this one: <https://metabolicatlas.org/api/v2/metabolites/MAM00001c?model=MouseGem>. Let's try it: 

```{r}
res <- GET("https://metabolicatlas.org/api/v2/metabolites/MAM00001c?model=MouseGem")
```

By doing this, I get a list of list with the info. I think that with the TSV of metabolites I have found (see below), it is enough, so. 

```{r}
data <- fromJSON(rawToChar(res$content))
data
```

Therefore, let's leave it like that and eventually I will try to solve it. Let's work with the IDs from the metabolic atlas. 

```{r, eval = FALSE}
# unlist(mouseGEM.mat[[which(rownames(mouseGEM.mat) == "compNames")]])
# rownames(mouseGEM.mat)
# metabolites_paper <- unlist(mouseGEM.mat[[which(rownames(mouseGEM.mat) == "c")]])
# HMDB_paper <- unlist(sapply(recon3D_paper[[16]], function(x){
#   if(dim(x[[1]])[1] > 0)
#   {
#     return(x)
#   } else
#   {
#     return("unknown")
#   }
# }))
```

```{r}
all(grepl("^MAM\\d", metabolites.mouseGEM))
```

Once he does all the ID matching (with HMDB and BIGG), he creates a mapping DF to have like ametabolite metadata. I iwll create the same but for my IDs. As I have the same number of identified metabolites with the MA ID as number of compounds, I can directly do it. on the other hand, for formulas, I have to iterate over the original matrix where NA entries are still present. 

```{r}
length(metabolites.mouseGEM)
length(metabolites_names.mouseGEM)
```


```{r}
metabolites_formulas.mouseGEM <- unlist(
  sapply(
    mouseGEM.mat[[which(rownames(mouseGEM.mat) == "metFormulas")]], 
    function(x) {
      if(dim(x[[1]])[1] > 0) {
        return(x)
      } else {
        return("unknown")
      }
    }
  )
)
```


```{r}
sum(grepl("unknown", metabolites_formulas.mouseGEM))
```

```{r}
metabolites_inchi.mouseGEM <- unlist(
  sapply(
    mouseGEM.mat[[which(rownames(mouseGEM.mat) == "inchis")]], 
    function(x) {
      if(dim(x[[1]])[1] > 0) {
        return(x)
      } else {
        return("unknown")
      }
    }
  )
)
```

```{r}
sum(grepl("unknown", metabolites_inchi.mouseGEM))
```

```{r}
mapping_table.mouseGEM <- data.frame(
  ID.MetabolicAtlas = metabolites.mouseGEM,
  Metabolite.Name = metabolites_names.mouseGEM, 
  Metabolite.Formula = metabolites_formulas.mouseGEM,
  Inchi = metabolites_inchi.mouseGEM
)
```

```{r}
# View(mapping_table.mouseGEM)
```

Now, he creates a mapping vector. I don't really need it. Then, he modifies the format of the metabolites vector, but again I cannot do it. 

```{r}
# metabolites.mouseGEM
# reaction_to_genes.mouseGEM
```

Now, he creates a reactions DF in which there will be metabolites connected to enzymes. It is a mega for loop and in some parts Idk why he does some things. I am giong to leave it like that and once I understand what he wants, I'll modify it. 

```{r}
#create the 2 coulmn format network between metabolites and enzymes
reactions_df.mouseGEM <- list()
```

```{r}
reaction_to_genes.mouseGEM.original.2 <- reaction_to_genes.mouseGEM
```


```{r}
## number of reactions contained in the S matrix: 
length(S.mouseGEM[1,])
## number of reactions in the lbf dataframe 8direction of these reactions:
nrow(lbs)
```

```{r}
#we do reactions 1 by 1 (colunms of stochiometric matrix)
for (i in 1:length(S.mouseGEM[1,])) {
  # print(i)
  #get the reactions stochiometry
  reaction <- S.mouseGEM[,i]
  
  #modify gene name so reactions that are catalised by same enzyme stay separated
  reaction_to_genes.mouseGEM[reaction_to_genes.mouseGEM$V1 == i, 2] <- paste(
    paste("Gene", i, sep = ""), 
    reaction_to_genes.mouseGEM[reaction_to_genes.mouseGEM$V1 == i,2], 
    sep = "__"
  )
  
  #get the enzymes associated with reaction
  genes <- reaction_to_genes.mouseGEM[reaction_to_genes.mouseGEM$V1 == i, 2]
  
  if(lbs[i, 4] == "forward") {
    #get reactant
    reactants <- metabolites.mouseGEM[reaction == -1]
    
    #get the products
    products <- metabolites.mouseGEM[reaction == 1]
  } else {
    #get reactant
    reactants <- metabolites.mouseGEM[reaction == 1]
    
    #get the products
    products <- metabolites.mouseGEM[reaction == -1]
  }
  
  # reactants[which(reactants %in% names(mapping_vec))] <- mapping_vec[reactants[which(reactants %in% names(mapping_vec))]]
  # products[which(products %in% names(mapping_vec))] <- mapping_vec[products[which(products %in% names(mapping_vec))]]
  # 
  reactants <- paste("Metab__", reactants, sep = "")
  products <- paste("Metab__", products, sep = "")
  
  #check how many rows(interactions) will be necessary in the 2 column format of this reaction
  number_of_interations <- length(reactants) + length(products)
  
  #now for each enzymes, we create a two column dataframe recapitulating the interactions between the metabolites and this enzyme
  reaction_df <- list()
  j <- 1
  for(gene in genes) {
    gene_df <- as.data.frame(matrix(NA, number_of_interations, 2))
    gene_df$V1 <- c(reactants,rep(gene, number_of_interations - length(reactants))) #reactants followed by the enzyme (the enzyme is repeated as many time as they are products)
    gene_df$V2 <- c(rep(gene, number_of_interations - length(products)), products) #enzyme(repeated asmany time as they are reactants) followed by products
    ## here, Idk what he does
    if(length(reactants) >= 2 & length(products) >= 2 & length(products) == length(reactants)) {
      if(sum(gsub("_[a-z]$", "", reactants) == gsub("_[a-z]$", "", products)) == length(reactants)) {
        prefix <- str_extract(gene, "Gene[0-9]+__")
        prefix <- gsub("__", "", prefix)
        gene <- gsub("Gene[0-9]+__", "", gene)
        for(k in 1:length(reactants)) {
          new_prefix <- paste("0000", k, sep = "")
          new_prefix <- paste(new_prefix, "__", sep = "")
          new_prefix <- paste(prefix, new_prefix, sep = "")
          
          # if(grepl("_e$",gene_df[k,1]) |  grepl("_e$",gene_df[k+length(reactants),2])) #Remove external import and exports
          # {
          #   gene_df[k,] <- c(NA,NA)
          #   gene_df[k+length(reactants),] <- c(NA,NA)
          # } else
          # {
          #   gene_df[k,2] <- paste(new_prefix, gene, sep = "")
          #   gene_df[k+length(reactants),1] <- paste(new_prefix, gene, sep = "")
          # }
          
          gene_df[k, 2] <- paste(new_prefix, gene, sep = "")
          gene_df[k + length(reactants), 1] <- paste(new_prefix, gene, sep = "")
        }
      }
    }
    # if reaction is reversible, we do the same but inverse reactant and products
    if(reversible[i]) {
      gene_df_reverse <- as.data.frame(matrix(NA, number_of_interations, 2))
      gene_df_reverse$V1 <- c(rep(paste(gene, "_reverse", sep = ""), number_of_interations - length(products)), products)
      gene_df_reverse$V2 <- c(reactants,rep(paste(gene, "_reverse", sep = ""), number_of_interations - length(reactants)))
      gene_df <- as.data.frame(rbind(gene_df, gene_df_reverse))
    }
    
    # if(sum(grepl("_e$",as.character(c(gene_df[,1],gene_df[,2]))) > 0)) #remove external imports exports
    # {
    #   reaction_df[[j]] <- as.data.frame(matrix(NA,1,2))
    # } else
    # {
    #   reaction_df[[j]] <- gene_df 
    # }
    
    reaction_df[[j]] <- gene_df
    j <- j + 1
  }
  #the individual enzyme dataframes of this reaction are combined into one reaction dataframe
  reaction_df <- as.data.frame(do.call(rbind, reaction_df))
  
  #the reaction dataframe is added to the list of all reaction reaction dataframes
  reactions_df.mouseGEM[[i]] <- reaction_df
}
```

```{r}
reactions_df.mouseGEM[c(1:10)]
```

```{r}
#the individual reaction dataframesare combined into one
reactions_df.mouseGEM <- as.data.frame(do.call(rbind, reactions_df.mouseGEM))

reactions_df.mouseGEM <- reactions_df.mouseGEM[reactions_df.mouseGEM$V1 != "Metab__" & reactions_df.mouseGEM$V2 != "Metab__",]

reactions_df.mouseGEM <- reactions_df.mouseGEM[complete.cases(reactions_df.mouseGEM),]
```

```{r}
reactions_df.mouseGEM
```


Now, we have a two column data frame between metabolites and enzymes. I don't know why this format, because genes and metabolites are mixed up between the two columns... Not sure. let's continue with the script. 

Here, I guess he wants to remove the second part of each entry (after __). I think he only wants to do this for the genes and not the metabolites, but I have to check it out in any case. Moreover, in some reactions, the ID he creates (Gene1, for instance) is repeated in different genes. I mean, there are 1 gene per reaction even though there are reactions with more than one gene. In the final network, i think he pretends to link only his IDs and not the actual genes (Gene1 --> Metab1), but i don't get why not using all the genes. 

```{r}
gene_metab_network <- reactions_df.mouseGEM
## does not work: omy case is different from his
gene_metab_network$V1 <- gsub("_[a-z]$", "", gene_metab_network$V1)
gene_metab_network$V2 <- gsub("_[a-z]$", "", gene_metab_network$V2)
```


```{r}
nodes <- rep(1, length(unique(c(gene_metab_network$V1, gene_metab_network$V2))))
names(nodes) <- unique(c(gene_metab_network$V1, gene_metab_network$V2))

metabs <- nodes[grepl("Metab__",names(nodes))]
```


```{r}
i <- 1
for (metab in names(metabs)) {
  # print(i)
  metabs[metab] <- sum(metab == gene_metab_network$V1)
  metabs[metab] <- metabs[metab] + sum(metab == gene_metab_network$V2)
  i <- i + 1
}
```

In this part, those metabolites with a number of connections greater than 400 are pruned because are considered cofactors (metabolites important for some reactions, but not the main products of the reactions). 

```{r}
metabs_sorted <- sort(metabs, decreasing = T)

cofactor <- metabs_sorted[metabs_sorted >= 400]
cofactor

#smallest number of connections before we find important metabolties
metabs_sorted <- metabs_sorted[metabs_sorted < 400] 
#glycine and glutamate both have more than 300 connections lol
```


```{r}
reactions_df_no_cofac <- reactions_df.mouseGEM[
  gsub("_[a-z]$","",reactions_df.mouseGEM$V1) %in% names(metabs_sorted) | 
    gsub("_[a-z]$","",reactions_df.mouseGEM$V2) %in% names(metabs_sorted),
]

names(reactions_df_no_cofac) <- c("source","target")

reactions_df_no_cofac$source <- gsub("__NA$","__orphanReacNA",reactions_df_no_cofac$source)
reactions_df_no_cofac$target <- gsub("__NA$","__orphanReacNA",reactions_df_no_cofac$target)
```

Finally, we have this dataframe of metabolites and genes (source --> target). 

### Trying to incorporate info from other databases

I wanted to directly use the API the Metabolic Atlas provides, but it does not work for me. I have emailed them just in case it is sth related to the API and not my problem. In any case, by checking the github repo where this model comes from (<https://github.com/SysBioChalmers/Mouse-GEM/tree/main/model>), I have found that they provide a TSV file with info mapping IDs from one ddbb to another. Let's check it out. In addition, they also provide a TSV with reactions, which can be useful because the reactions also have the ID of their ddbb. 

```{r}
metabolites.IDs.mouseGEM <- read.delim(file.path(dataPath, "Mouse-GEM", "model", "metabolites.tsv"))
reactions.IDs.mouseGEM <- read.delim(file.path(dataPath, "Mouse-GEM", "model", "reactions.tsv"))
```

Just to see how many metabolites used in my network are present in this ddbb with a metHMDBID entry: 

```{r}
all(metabolites.IDs.mouseGEM$mets %in% metabolites.mouseGEM)
length(metabolites.mouseGEM)
sum(metabolites.IDs.mouseGEM$metHMDBID[match(metabolites.mouseGEM, metabolites.IDs.mouseGEM$mets)] != "")
```

Only 2187 metabolites have a HDMB ID. This is bad... I'll have to talk to Aurelien. 

# About mapping metabolites to HMDB database

Aurelien used the following R packages: 

* `hmdbQuery`
* `metaboliteIDmapping`

In my case, Idk if I can use them because the model comes from a ddbb that doesn't seem to be very 'official'. In any case, let's try them: 


